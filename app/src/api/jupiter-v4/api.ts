//@ts-nocheck
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Jupiter API
 * Jupiter quote and swap API
 *
 * OpenAPI spec version: 0.0.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface Def0
 */
export interface Def0 {
    /**
     *
     * @type {string}
     * @memberof Def0
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Def0
     */
    label?: string;
    /**
     *
     * @type {string}
     * @memberof Def0
     */
    inputMint?: string;
    /**
     *
     * @type {string}
     * @memberof Def0
     */
    outputMint?: string;
    /**
     *
     * @type {boolean}
     * @memberof Def0
     */
    notEnoughLiquidity?: boolean;
    /**
     *
     * @type {string}
     * @memberof Def0
     */
    inAmount?: string;
    /**
     *
     * @type {string}
     * @memberof Def0
     */
    outAmount?: string;
    /**
     *
     * @type {string}
     * @memberof Def0
     */
    minInAmount?: string;
    /**
     *
     * @type {string}
     * @memberof Def0
     */
    minOutAmount?: string;
    /**
     *
     * @type {number}
     * @memberof Def0
     */
    priceImpactPct?: number;
    /**
     *
     * @type {Def0LpFee}
     * @memberof Def0
     */
    lpFee?: Def0LpFee;
    /**
     *
     * @type {Def0LpFee}
     * @memberof Def0
     */
    platformFee?: Def0LpFee;
}
/**
 *
 * @export
 * @interface Def0LpFee
 */
export interface Def0LpFee {
    /**
     *
     * @type {string}
     * @memberof Def0LpFee
     */
    amount?: string;
    /**
     *
     * @type {string}
     * @memberof Def0LpFee
     */
    mint?: string;
    /**
     *
     * @type {number}
     * @memberof Def0LpFee
     */
    pct?: number;
}
/**
 *
 * @export
 * @interface Def1
 */
export interface Def1 {
    /**
     *
     * @type {string}
     * @memberof Def1
     */
    inAmount: string;
    /**
     *
     * @type {string}
     * @memberof Def1
     */
    outAmount: string;
    /**
     *
     * @type {number}
     * @memberof Def1
     */
    priceImpactPct: number;
    /**
     *
     * @type {Array<Def1MarketInfos>}
     * @memberof Def1
     */
    marketInfos: Array<Def1MarketInfos>;
    /**
     *
     * @type {string}
     * @memberof Def1
     */
    amount: string;
    /**
     *
     * @type {number}
     * @memberof Def1
     */
    slippageBps: number;
    /**
     * The threshold for the swap based on the provided slippage: when swapMode is ExactIn the minimum out amount, when swapMode is ExactOut the maximum in amount
     * @type {string}
     * @memberof Def1
     */
    otherAmountThreshold: string;
    /**
     *
     * @type {string}
     * @memberof Def1
     */
    swapMode: Def1.SwapModeEnum;
    /**
     *
     * @type {Def1Fees}
     * @memberof Def1
     */
    fees?: Def1Fees;
}

/**
 * @export
 * @namespace Def1
 */
export namespace Def1 {
    /**
     * @export
     * @enum {string}
     */
    export enum SwapModeEnum {
        ExactIn = <any> 'ExactIn',
        ExactOut = <any> 'ExactOut'
    }
}
/**
 * Only returned when userPublicKey is given to /quote
 * @export
 * @interface Def1Fees
 */
export interface Def1Fees {
    /**
     * This inidicate the total amount needed for signing transaction(s). Value in lamports.
     * @type {number}
     * @memberof Def1Fees
     */
    signatureFee?: number;
    /**
     * This inidicate the total amount needed for deposit of serum order account(s). Value in lamports.
     * @type {Array<number>}
     * @memberof Def1Fees
     */
    openOrdersDeposits?: Array<number>;
    /**
     * This inidicate the total amount needed for deposit of associative token account(s). Value in lamports.
     * @type {Array<number>}
     * @memberof Def1Fees
     */
    ataDeposits?: Array<number>;
    /**
     * This inidicate the total lamports needed for fees and deposits above.
     * @type {number}
     * @memberof Def1Fees
     */
    totalFeeAndDeposits?: number;
    /**
     * This inidicate the minimum lamports needed for transaction(s). Might be used to create wrapped SOL and will be returned when the wrapped SOL is closed.
     * @type {number}
     * @memberof Def1Fees
     */
    minimumSOLForTransaction?: number;
}
/**
 *
 * @export
 * @interface Def1MarketInfos
 */
export interface Def1MarketInfos {
    /**
     *
     * @type {string}
     * @memberof Def1MarketInfos
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Def1MarketInfos
     */
    label?: string;
    /**
     *
     * @type {string}
     * @memberof Def1MarketInfos
     */
    inputMint?: string;
    /**
     *
     * @type {string}
     * @memberof Def1MarketInfos
     */
    outputMint?: string;
    /**
     *
     * @type {boolean}
     * @memberof Def1MarketInfos
     */
    notEnoughLiquidity?: boolean;
    /**
     *
     * @type {string}
     * @memberof Def1MarketInfos
     */
    inAmount?: string;
    /**
     *
     * @type {string}
     * @memberof Def1MarketInfos
     */
    outAmount?: string;
    /**
     *
     * @type {string}
     * @memberof Def1MarketInfos
     */
    minInAmount?: string;
    /**
     *
     * @type {string}
     * @memberof Def1MarketInfos
     */
    minOutAmount?: string;
    /**
     *
     * @type {number}
     * @memberof Def1MarketInfos
     */
    priceImpactPct?: number;
    /**
     *
     * @type {Def0LpFee}
     * @memberof Def1MarketInfos
     */
    lpFee?: Def0LpFee;
    /**
     *
     * @type {Def0LpFee}
     * @memberof Def1MarketInfos
     */
    platformFee?: Def0LpFee;
}
/**
 *
 * @export
 * @interface Def2
 */
export interface Def2 {
    /**
     * Address of the token
     * @type {string}
     * @memberof Def2
     */
    id?: string;
    /**
     * Symbol of the token
     * @type {string}
     * @memberof Def2
     */
    mintSymbol?: string;
    /**
     * Address of the vs token
     * @type {string}
     * @memberof Def2
     */
    vsToken?: string;
    /**
     * Symbol of the vs token
     * @type {string}
     * @memberof Def2
     */
    vsTokenSymbol?: string;
    /**
     * Default to 1 unit of the token worth in USDC if vsToken is not specified.
     * @type {number}
     * @memberof Def2
     */
    price?: number;
}
/**
 *
 * @export
 * @interface Def3
 */
export interface Def3 extends null<String, Def2> {
    [key: string]: Def2;

}
/**
 * Default response
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {Array<InlineResponse200Data>}
     * @memberof InlineResponse200
     */
    data?: Array<InlineResponse200Data>;
    /**
     *
     * @type {number}
     * @memberof InlineResponse200
     */
    timeTaken?: number;
    /**
     *
     * @type {number}
     * @memberof InlineResponse200
     */
    contextSlot?: number;
}
/**
 * Default response
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * Base64 encoded transaction
     * @type {string}
     * @memberof InlineResponse2001
     */
    swapTransaction?: string;
}
/**
 * Default response with ids which return an object. Refer to Price hash model below. If the id is invalid, it will not return in the hash.
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     *
     * @type {Def3}
     * @memberof InlineResponse2002
     */
    data?: Def3;
    /**
     *
     * @type {number}
     * @memberof InlineResponse2002
     */
    timeTaken?: number;
    /**
     *
     * @type {number}
     * @memberof InlineResponse2002
     */
    contextSlot?: number;
}
/**
 * Default response
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * All the mints that are indexed to match in indexedRouteMap
     * @type {Array<string>}
     * @memberof InlineResponse2003
     */
    mintKeys?: Array<string>;
    /**
     * All the possible route and their corresponding output mints
     * @type {{ [key: string]: Array<number>; }}
     * @memberof InlineResponse2003
     */
    indexedRouteMap?: { [key: string]: Array<number>; };
}
/**
 *
 * @export
 * @interface InlineResponse200Data
 */
export interface InlineResponse200Data {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Data
     */
    inAmount: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Data
     */
    outAmount: string;
    /**
     *
     * @type {number}
     * @memberof InlineResponse200Data
     */
    priceImpactPct: number;
    /**
     *
     * @type {Array<Def1MarketInfos>}
     * @memberof InlineResponse200Data
     */
    marketInfos: Array<Def1MarketInfos>;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Data
     */
    amount: string;
    /**
     *
     * @type {number}
     * @memberof InlineResponse200Data
     */
    slippageBps: number;
    /**
     * The threshold for the swap based on the provided slippage: when swapMode is ExactIn the minimum out amount, when swapMode is ExactOut the maximum in amount
     * @type {string}
     * @memberof InlineResponse200Data
     */
    otherAmountThreshold: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Data
     */
    swapMode: InlineResponse200Data.SwapModeEnum;
    /**
     *
     * @type {Def1Fees}
     * @memberof InlineResponse200Data
     */
    fees?: Def1Fees;
}

/**
 * @export
 * @namespace InlineResponse200Data
 */
export namespace InlineResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum SwapModeEnum {
        ExactIn = <any> 'ExactIn',
        ExactOut = <any> 'ExactOut'
    }
}
/**
 * Duplicate symbol found for input or vsToken. The server will respond an error structure which contains the conflict addresses. User will have to use address mode instead.
 * @export
 * @interface InlineResponse409
 */
export interface InlineResponse409 {
    /**
     *
     * @type {InlineResponse409Data}
     * @memberof InlineResponse409
     */
    data?: InlineResponse409Data;
}
/**
 *
 * @export
 * @interface InlineResponse409Data
 */
export interface InlineResponse409Data {
    /**
     * Duplicated symbol found for [symbol], use one of the address instead
     * @type {string}
     * @memberof InlineResponse409Data
     */
    error?: string;
    /**
     * List of addresses for the symbol
     * @type {Array}
     * @memberof InlineResponse409Data
     */
    addresses?: Array;
}
/**
 *
 * @export
 * @interface V4SwapBody
 */
export interface V4SwapBody {
    /**
     *
     * @type {Def1}
     * @memberof V4SwapBody
     */
    route: Def1;
    /**
     * Public key of the user
     * @type {string}
     * @memberof V4SwapBody
     */
    userPublicKey: string;
    /**
     * Wrap/unwrap SOL
     * @type {boolean}
     * @memberof V4SwapBody
     */
    wrapUnwrapSOL?: boolean;
    /**
     * Fee token account for the output token (only pass in if you set a feeBps)
     * @type {string}
     * @memberof V4SwapBody
     */
    feeAccount?: string;
    /**
     * Request a legacy transaction rather than the default versioned transaction, needs to be paired with a quote using asLegacyTransaction otherwise the transaction might be too large
     * @type {boolean}
     * @memberof V4SwapBody
     */
    asLegacyTransaction?: boolean;
    /**
     * compute unit price to prioritize the transaction, the additional fee will be compute unit consumed * computeUnitPriceMicroLamports
     * @type {number}
     * @memberof V4SwapBody
     */
    computeUnitPriceMicroLamports?: number;
    /**
     * Public key of the wallet that will receive the output of the swap, this assumes the associated token account exists, currently adds a token transfer
     * @type {string}
     * @memberof V4SwapBody
     */
    destinationWallet?: string;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a hash map, input mint as key and an array of valid output mint as values, token mints are indexed to reduce the file size
         * @param {boolean} [onlyDirectRoutes] Only return direct routes (no hoppings and split trade)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4IndexedRouteMapGet(onlyDirectRoutes?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v4/indexed-route-map`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (onlyDirectRoutes !== undefined) {
                localVarQueryParameter['onlyDirectRoutes'] = onlyDirectRoutes;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get simple price for a given input mint, output mint and amount
         * @summary Return simple price
         * @param {string} ids Symbol or address of a token, (e.g. SOL or EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v). Use &#x60;,&#x60; to query multiple tokens, e.g. (sol,btc,mer,&lt;address&gt;)
         * @param {string} [vsToken] Default to USDC. Symbol or address of a token, (e.g. SOL or EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v).
         * @param {number} [vsAmount] Unit amount of specified input token. Default to 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4PriceGet(ids: string, vsToken?: string, vsAmount?: number, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling v4PriceGet.');
            }
            const localVarPath = `/v4/price`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (vsToken !== undefined) {
                localVarQueryParameter['vsToken'] = vsToken;
            }

            if (vsAmount !== undefined) {
                localVarQueryParameter['vsAmount'] = vsAmount;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get quote for a given input mint, output mint and amount
         * @summary Return route
         * @param {string} inputMint inputMint
         * @param {string} outputMint outputMint
         * @param {string} amount amount
         * @param {string} [swapMode] Swap mode, default is ExactIn
         * @param {number} [slippageBps] Slippage bps
         * @param {number} [feeBps] Fee BPS (only pass in if you want to charge a fee on this swap)
         * @param {boolean} [onlyDirectRoutes] Only return direct routes (no hoppings and split trade)
         * @param {string} [userPublicKey] Public key of the user (only pass in if you want deposit and fee being returned, might slow down query)
         * @param {boolean} [asLegacyTransaction] Only return routes that can be done in a single legacy transaction. (Routes might be limited)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4QuoteGet(inputMint: string, outputMint: string, amount: string, swapMode?: string, slippageBps?: number, feeBps?: number, onlyDirectRoutes?: boolean, userPublicKey?: string, asLegacyTransaction?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'inputMint' is not null or undefined
            if (inputMint === null || inputMint === undefined) {
                throw new RequiredError('inputMint','Required parameter inputMint was null or undefined when calling v4QuoteGet.');
            }
            // verify required parameter 'outputMint' is not null or undefined
            if (outputMint === null || outputMint === undefined) {
                throw new RequiredError('outputMint','Required parameter outputMint was null or undefined when calling v4QuoteGet.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling v4QuoteGet.');
            }
            const localVarPath = `/v4/quote`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inputMint !== undefined) {
                localVarQueryParameter['inputMint'] = inputMint;
            }

            if (outputMint !== undefined) {
                localVarQueryParameter['outputMint'] = outputMint;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (swapMode !== undefined) {
                localVarQueryParameter['swapMode'] = swapMode;
            }

            if (slippageBps !== undefined) {
                localVarQueryParameter['slippageBps'] = slippageBps;
            }

            if (feeBps !== undefined) {
                localVarQueryParameter['feeBps'] = feeBps;
            }

            if (onlyDirectRoutes !== undefined) {
                localVarQueryParameter['onlyDirectRoutes'] = onlyDirectRoutes;
            }

            if (userPublicKey !== undefined) {
                localVarQueryParameter['userPublicKey'] = userPublicKey;
            }

            if (asLegacyTransaction !== undefined) {
                localVarQueryParameter['asLegacyTransaction'] = asLegacyTransaction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get swap serialized transactions for a route
         * @summary Return setup, swap and cleanup transactions
         * @param {V4SwapBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4SwapPost(body?: V4SwapBody, options: any = {}): FetchArgs {
            const localVarPath = `/v4/swap`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V4SwapBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a hash map, input mint as key and an array of valid output mint as values, token mints are indexed to reduce the file size
         * @param {boolean} [onlyDirectRoutes] Only return direct routes (no hoppings and split trade)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4IndexedRouteMapGet(onlyDirectRoutes?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).v4IndexedRouteMapGet(onlyDirectRoutes, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get simple price for a given input mint, output mint and amount
         * @summary Return simple price
         * @param {string} ids Symbol or address of a token, (e.g. SOL or EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v). Use &#x60;,&#x60; to query multiple tokens, e.g. (sol,btc,mer,&lt;address&gt;)
         * @param {string} [vsToken] Default to USDC. Symbol or address of a token, (e.g. SOL or EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v).
         * @param {number} [vsAmount] Unit amount of specified input token. Default to 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4PriceGet(ids: string, vsToken?: string, vsAmount?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).v4PriceGet(ids, vsToken, vsAmount, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get quote for a given input mint, output mint and amount
         * @summary Return route
         * @param {string} inputMint inputMint
         * @param {string} outputMint outputMint
         * @param {string} amount amount
         * @param {string} [swapMode] Swap mode, default is ExactIn
         * @param {number} [slippageBps] Slippage bps
         * @param {number} [feeBps] Fee BPS (only pass in if you want to charge a fee on this swap)
         * @param {boolean} [onlyDirectRoutes] Only return direct routes (no hoppings and split trade)
         * @param {string} [userPublicKey] Public key of the user (only pass in if you want deposit and fee being returned, might slow down query)
         * @param {boolean} [asLegacyTransaction] Only return routes that can be done in a single legacy transaction. (Routes might be limited)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4QuoteGet(inputMint: string, outputMint: string, amount: string, swapMode?: string, slippageBps?: number, feeBps?: number, onlyDirectRoutes?: boolean, userPublicKey?: string, asLegacyTransaction?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).v4QuoteGet(inputMint, outputMint, amount, swapMode, slippageBps, feeBps, onlyDirectRoutes, userPublicKey, asLegacyTransaction, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get swap serialized transactions for a route
         * @summary Return setup, swap and cleanup transactions
         * @param {V4SwapBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4SwapPost(body?: V4SwapBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).v4SwapPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a hash map, input mint as key and an array of valid output mint as values, token mints are indexed to reduce the file size
         * @param {boolean} [onlyDirectRoutes] Only return direct routes (no hoppings and split trade)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4IndexedRouteMapGet(onlyDirectRoutes?: boolean, options?: any) {
            return DefaultApiFp(configuration).v4IndexedRouteMapGet(onlyDirectRoutes, options)(fetch, basePath);
        },
        /**
         * Get simple price for a given input mint, output mint and amount
         * @summary Return simple price
         * @param {string} ids Symbol or address of a token, (e.g. SOL or EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v). Use &#x60;,&#x60; to query multiple tokens, e.g. (sol,btc,mer,&lt;address&gt;)
         * @param {string} [vsToken] Default to USDC. Symbol or address of a token, (e.g. SOL or EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v).
         * @param {number} [vsAmount] Unit amount of specified input token. Default to 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4PriceGet(ids: string, vsToken?: string, vsAmount?: number, options?: any) {
            return DefaultApiFp(configuration).v4PriceGet(ids, vsToken, vsAmount, options)(fetch, basePath);
        },
        /**
         * Get quote for a given input mint, output mint and amount
         * @summary Return route
         * @param {string} inputMint inputMint
         * @param {string} outputMint outputMint
         * @param {string} amount amount
         * @param {string} [swapMode] Swap mode, default is ExactIn
         * @param {number} [slippageBps] Slippage bps
         * @param {number} [feeBps] Fee BPS (only pass in if you want to charge a fee on this swap)
         * @param {boolean} [onlyDirectRoutes] Only return direct routes (no hoppings and split trade)
         * @param {string} [userPublicKey] Public key of the user (only pass in if you want deposit and fee being returned, might slow down query)
         * @param {boolean} [asLegacyTransaction] Only return routes that can be done in a single legacy transaction. (Routes might be limited)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4QuoteGet(inputMint: string, outputMint: string, amount: string, swapMode?: string, slippageBps?: number, feeBps?: number, onlyDirectRoutes?: boolean, userPublicKey?: string, asLegacyTransaction?: boolean, options?: any) {
            return DefaultApiFp(configuration).v4QuoteGet(inputMint, outputMint, amount, swapMode, slippageBps, feeBps, onlyDirectRoutes, userPublicKey, asLegacyTransaction, options)(fetch, basePath);
        },
        /**
         * Get swap serialized transactions for a route
         * @summary Return setup, swap and cleanup transactions
         * @param {V4SwapBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4SwapPost(body?: V4SwapBody, options?: any) {
            return DefaultApiFp(configuration).v4SwapPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Returns a hash map, input mint as key and an array of valid output mint as values, token mints are indexed to reduce the file size
     * @param {boolean} [onlyDirectRoutes] Only return direct routes (no hoppings and split trade)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v4IndexedRouteMapGet(onlyDirectRoutes?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).v4IndexedRouteMapGet(onlyDirectRoutes, options)(this.fetch, this.basePath);
    }

    /**
     * Get simple price for a given input mint, output mint and amount
     * @summary Return simple price
     * @param {string} ids Symbol or address of a token, (e.g. SOL or EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v). Use &#x60;,&#x60; to query multiple tokens, e.g. (sol,btc,mer,&lt;address&gt;)
     * @param {string} [vsToken] Default to USDC. Symbol or address of a token, (e.g. SOL or EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v).
     * @param {number} [vsAmount] Unit amount of specified input token. Default to 1.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v4PriceGet(ids: string, vsToken?: string, vsAmount?: number, options?: any) {
        return DefaultApiFp(this.configuration).v4PriceGet(ids, vsToken, vsAmount, options)(this.fetch, this.basePath);
    }

    /**
     * Get quote for a given input mint, output mint and amount
     * @summary Return route
     * @param {string} inputMint inputMint
     * @param {string} outputMint outputMint
     * @param {string} amount amount
     * @param {string} [swapMode] Swap mode, default is ExactIn
     * @param {number} [slippageBps] Slippage bps
     * @param {number} [feeBps] Fee BPS (only pass in if you want to charge a fee on this swap)
     * @param {boolean} [onlyDirectRoutes] Only return direct routes (no hoppings and split trade)
     * @param {string} [userPublicKey] Public key of the user (only pass in if you want deposit and fee being returned, might slow down query)
     * @param {boolean} [asLegacyTransaction] Only return routes that can be done in a single legacy transaction. (Routes might be limited)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v4QuoteGet(inputMint: string, outputMint: string, amount: string, swapMode?: string, slippageBps?: number, feeBps?: number, onlyDirectRoutes?: boolean, userPublicKey?: string, asLegacyTransaction?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).v4QuoteGet(inputMint, outputMint, amount, swapMode, slippageBps, feeBps, onlyDirectRoutes, userPublicKey, asLegacyTransaction, options)(this.fetch, this.basePath);
    }

    /**
     * Get swap serialized transactions for a route
     * @summary Return setup, swap and cleanup transactions
     * @param {V4SwapBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v4SwapPost(body?: V4SwapBody, options?: any) {
        return DefaultApiFp(this.configuration).v4SwapPost(body, options)(this.fetch, this.basePath);
    }

}
