//@ts-nocheck
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * CoinGecko API V3
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 3.0.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.coingecko.com/api/v3".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * AssetPlatformsApi - fetch parameter creator
 * @export
 */
export const AssetPlatformsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all asset platforms
         * @summary List all asset platforms (Blockchain networks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetPlatformsGet(options: any = {}): FetchArgs {
            const localVarPath = `/asset_platforms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetPlatformsApi - functional programming interface
 * @export
 */
export const AssetPlatformsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all asset platforms
         * @summary List all asset platforms (Blockchain networks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetPlatformsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetPlatformsApiFetchParamCreator(configuration).assetPlatformsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetPlatformsApi - factory interface
 * @export
 */
export const AssetPlatformsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all asset platforms
         * @summary List all asset platforms (Blockchain networks)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetPlatformsGet(options?: any) {
            return AssetPlatformsApiFp(configuration).assetPlatformsGet(options)(fetch, basePath);
        },
    };
};

/**
 * AssetPlatformsApi - object-oriented interface
 * @export
 * @class AssetPlatformsApi
 * @extends {BaseAPI}
 */
export class AssetPlatformsApi extends BaseAPI {
    /**
     * List all asset platforms
     * @summary List all asset platforms (Blockchain networks)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetPlatformsApi
     */
    public assetPlatformsGet(options?: any) {
        return AssetPlatformsApiFp(this.configuration).assetPlatformsGet(options)(this.fetch, this.basePath);
    }

}
/**
 * CategoriesApi - fetch parameter creator
 * @export
 */
export const CategoriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all categories with market data
         * @summary List all categories with market data
         * @param {string} [order] valid values: &lt;b&gt;market_cap_desc (default), market_cap_asc, name_desc, name_asc, market_cap_change_24h_desc and market_cap_change_24h_asc&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsCategoriesGet(order?: string, options: any = {}): FetchArgs {
            const localVarPath = `/coins/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all categories
         * @summary List all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsCategoriesListGet(options: any = {}): FetchArgs {
            const localVarPath = `/coins/categories/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all categories with market data
         * @summary List all categories with market data
         * @param {string} [order] valid values: &lt;b&gt;market_cap_desc (default), market_cap_asc, name_desc, name_asc, market_cap_change_24h_desc and market_cap_change_24h_asc&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsCategoriesGet(order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).coinsCategoriesGet(order, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all categories
         * @summary List all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsCategoriesListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).coinsCategoriesListGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all categories with market data
         * @summary List all categories with market data
         * @param {string} [order] valid values: &lt;b&gt;market_cap_desc (default), market_cap_asc, name_desc, name_asc, market_cap_change_24h_desc and market_cap_change_24h_asc&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsCategoriesGet(order?: string, options?: any) {
            return CategoriesApiFp(configuration).coinsCategoriesGet(order, options)(fetch, basePath);
        },
        /**
         * List all categories
         * @summary List all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsCategoriesListGet(options?: any) {
            return CategoriesApiFp(configuration).coinsCategoriesListGet(options)(fetch, basePath);
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * List all categories with market data
     * @summary List all categories with market data
     * @param {string} [order] valid values: &lt;b&gt;market_cap_desc (default), market_cap_asc, name_desc, name_asc, market_cap_change_24h_desc and market_cap_change_24h_asc&lt;/b&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public coinsCategoriesGet(order?: string, options?: any) {
        return CategoriesApiFp(this.configuration).coinsCategoriesGet(order, options)(this.fetch, this.basePath);
    }

    /**
     * List all categories
     * @summary List all categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public coinsCategoriesListGet(options?: any) {
        return CategoriesApiFp(this.configuration).coinsCategoriesListGet(options)(this.fetch, this.basePath);
    }

}
/**
 * CoinsApi - fetch parameter creator
 * @export
 */
export const CoinsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current data (name, price, market, ... including exchange tickers) for a coin.<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/coins/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get current data (name, price, market, ... including exchange tickers) for a coin
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} [localization] Include all localized languages in response (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [tickers] Include tickers data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [marketData] Include market_data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [communityData] Include community_data data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [developerData] Include developer_data data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [sparkline] Include sparkline 7 days data (eg. true, false) &lt;b&gt;[default: false]&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdGet(id: string, localization?: string, tickers?: boolean, marketData?: boolean, communityData?: boolean, developerData?: boolean, sparkline?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coinsIdGet.');
            }
            const localVarPath = `/coins/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }

            if (marketData !== undefined) {
                localVarQueryParameter['market_data'] = marketData;
            }

            if (communityData !== undefined) {
                localVarQueryParameter['community_data'] = communityData;
            }

            if (developerData !== undefined) {
                localVarQueryParameter['developer_data'] = developerData;
            }

            if (sparkline !== undefined) {
                localVarQueryParameter['sparkline'] = sparkline;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical data (name, price, market, stats) at a given date for a coin
         * @summary Get historical data (name, price, market, stats) at a given date for a coin
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} date The date of data snapshot in dd-mm-yyyy eg. 30-12-2017
         * @param {string} [localization] Set to false to exclude localized languages in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdHistoryGet(id: string, date: string, localization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coinsIdHistoryGet.');
            }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling coinsIdHistoryGet.');
            }
            const localVarPath = `/coins/{id}/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical market data include price, market cap, and 24h volume (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from current time = 5 minute interval data</li><li>1 - 90 days from current time = hourly data</li><li>above 90 days from current time = daily data (00:00 UTC)</li></ul> </b>
         * @summary Get historical market data include price, market cap, and 24h volume (granularity auto)
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} days Data up to number of days ago (eg. 1,14,30,max)
         * @param {string} [interval] Data interval. Possible value: daily
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdMarketChartGet(id: string, vsCurrency: string, days: string, interval?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coinsIdMarketChartGet.');
            }
            // verify required parameter 'vsCurrency' is not null or undefined
            if (vsCurrency === null || vsCurrency === undefined) {
                throw new RequiredError('vsCurrency','Required parameter vsCurrency was null or undefined when calling coinsIdMarketChartGet.');
            }
            // verify required parameter 'days' is not null or undefined
            if (days === null || days === undefined) {
                throw new RequiredError('days','Required parameter days was null or undefined when calling coinsIdMarketChartGet.');
            }
            const localVarPath = `/coins/{id}/market_chart`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vsCurrency !== undefined) {
                localVarQueryParameter['vs_currency'] = vsCurrency;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from current time = 5 minute interval data</li><li>1 - 90 days from current time = hourly data</li><li>above 90 days from current time = daily data (00:00 UTC)</li></ul> </b>
         * @summary Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} from From date in UNIX Timestamp (eg. 1392577232)
         * @param {string} to To date in UNIX Timestamp (eg. 1422577232)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdMarketChartRangeGet(id: string, vsCurrency: string, from: string, to: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coinsIdMarketChartRangeGet.');
            }
            // verify required parameter 'vsCurrency' is not null or undefined
            if (vsCurrency === null || vsCurrency === undefined) {
                throw new RequiredError('vsCurrency','Required parameter vsCurrency was null or undefined when calling coinsIdMarketChartRangeGet.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling coinsIdMarketChartRangeGet.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling coinsIdMarketChartRangeGet.');
            }
            const localVarPath = `/coins/{id}/market_chart/range`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vsCurrency !== undefined) {
                localVarQueryParameter['vs_currency'] = vsCurrency;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Candle's body:  1 - 2 days: 30 minutes 3 - 30 days: 4 hours 31 days and beyond: 4 days
         * @summary Get coin's OHLC
         * @param {string} id pass the coin id (can be obtained from /coins/list) eg. bitcoin
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} days  Data up to number of days ago (1/7/14/30/90/180/365/max)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdOhlcGet(id: string, vsCurrency: string, days: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coinsIdOhlcGet.');
            }
            // verify required parameter 'vsCurrency' is not null or undefined
            if (vsCurrency === null || vsCurrency === undefined) {
                throw new RequiredError('vsCurrency','Required parameter vsCurrency was null or undefined when calling coinsIdOhlcGet.');
            }
            // verify required parameter 'days' is not null or undefined
            if (days === null || days === undefined) {
                throw new RequiredError('days','Required parameter days was null or undefined when calling coinsIdOhlcGet.');
            }
            const localVarPath = `/coins/{id}/ohlc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vsCurrency !== undefined) {
                localVarQueryParameter['vs_currency'] = vsCurrency;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get coin tickers (paginated to 100 items)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get coin tickers (paginated to 100 items)
         * @param {string} id pass the coin id (can be obtained from /coins/list) eg. bitcoin
         * @param {string} [exchangeIds] filter results by exchange_ids (ref: v3/exchanges/list)
         * @param {string} [includeExchangeLogo] flag to show exchange_logo
         * @param {number} [page] Page through results
         * @param {string} [order] valid values: &lt;b&gt;trust_score_desc (default), trust_score_asc and volume_desc&lt;/b&gt;
         * @param {string} [depth] flag to show 2% orderbook depth. valid values: true, false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdTickersGet(id: string, exchangeIds?: string, includeExchangeLogo?: string, page?: number, order?: string, depth?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coinsIdTickersGet.');
            }
            const localVarPath = `/coins/{id}/tickers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (exchangeIds !== undefined) {
                localVarQueryParameter['exchange_ids'] = exchangeIds;
            }

            if (includeExchangeLogo !== undefined) {
                localVarQueryParameter['include_exchange_logo'] = includeExchangeLogo;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to obtain all the coins' id in order to make API calls
         * @summary List all supported coins id, name and symbol (no pagination required)
         * @param {boolean} [includePlatform] flag to include platform contract addresses (eg. 0x.... for Ethereum based tokens).   valid values: true, false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsListGet(includePlatform?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/coins/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includePlatform !== undefined) {
                localVarQueryParameter['include_platform'] = includePlatform;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to obtain all the coins market data (price, market cap, volume)
         * @summary List all supported coins price, market cap, volume, and market related data
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} [ids] The ids of the coin, comma separated crytocurrency symbols (base). refers to &#x60;/coins/list&#x60;. &lt;b&gt;When left empty, returns numbers the coins observing the params &#x60;limit&#x60; and &#x60;start&#x60;&lt;/b&gt;
         * @param {string} [category] filter by coin category. Refer to /coin/categories/list
         * @param {string} [order] valid values: &lt;b&gt;market_cap_desc, gecko_desc, gecko_asc, market_cap_asc, market_cap_desc, volume_asc, volume_desc, id_asc, id_desc&lt;/b&gt; sort results by field.
         * @param {number} [perPage] valid values: 1..250  Total results per page
         * @param {number} [page] Page through results
         * @param {boolean} [sparkline] Include sparkline 7 days data (eg. true, false)
         * @param {string} [priceChangePercentage] Include price change percentage in &lt;b&gt;1h, 24h, 7d, 14d, 30d, 200d, 1y&lt;/b&gt; (eg. &#x27;&#x60;1h,24h,7d&#x60;&#x27; comma-separated, invalid values will be discarded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsMarketsGet(vsCurrency: string, ids?: string, category?: string, order?: string, perPage?: number, page?: number, sparkline?: boolean, priceChangePercentage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'vsCurrency' is not null or undefined
            if (vsCurrency === null || vsCurrency === undefined) {
                throw new RequiredError('vsCurrency','Required parameter vsCurrency was null or undefined when calling coinsMarketsGet.');
            }
            const localVarPath = `/coins/markets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vsCurrency !== undefined) {
                localVarQueryParameter['vs_currency'] = vsCurrency;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sparkline !== undefined) {
                localVarQueryParameter['sparkline'] = sparkline;
            }

            if (priceChangePercentage !== undefined) {
                localVarQueryParameter['price_change_percentage'] = priceChangePercentage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoinsApi - functional programming interface
 * @export
 */
export const CoinsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get current data (name, price, market, ... including exchange tickers) for a coin.<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/coins/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get current data (name, price, market, ... including exchange tickers) for a coin
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} [localization] Include all localized languages in response (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [tickers] Include tickers data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [marketData] Include market_data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [communityData] Include community_data data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [developerData] Include developer_data data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [sparkline] Include sparkline 7 days data (eg. true, false) &lt;b&gt;[default: false]&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdGet(id: string, localization?: string, tickers?: boolean, marketData?: boolean, communityData?: boolean, developerData?: boolean, sparkline?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoinsApiFetchParamCreator(configuration).coinsIdGet(id, localization, tickers, marketData, communityData, developerData, sparkline, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get historical data (name, price, market, stats) at a given date for a coin
         * @summary Get historical data (name, price, market, stats) at a given date for a coin
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} date The date of data snapshot in dd-mm-yyyy eg. 30-12-2017
         * @param {string} [localization] Set to false to exclude localized languages in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdHistoryGet(id: string, date: string, localization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoinsApiFetchParamCreator(configuration).coinsIdHistoryGet(id, date, localization, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get historical market data include price, market cap, and 24h volume (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from current time = 5 minute interval data</li><li>1 - 90 days from current time = hourly data</li><li>above 90 days from current time = daily data (00:00 UTC)</li></ul> </b>
         * @summary Get historical market data include price, market cap, and 24h volume (granularity auto)
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} days Data up to number of days ago (eg. 1,14,30,max)
         * @param {string} [interval] Data interval. Possible value: daily
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdMarketChartGet(id: string, vsCurrency: string, days: string, interval?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoinsApiFetchParamCreator(configuration).coinsIdMarketChartGet(id, vsCurrency, days, interval, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from current time = 5 minute interval data</li><li>1 - 90 days from current time = hourly data</li><li>above 90 days from current time = daily data (00:00 UTC)</li></ul> </b>
         * @summary Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} from From date in UNIX Timestamp (eg. 1392577232)
         * @param {string} to To date in UNIX Timestamp (eg. 1422577232)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdMarketChartRangeGet(id: string, vsCurrency: string, from: string, to: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoinsApiFetchParamCreator(configuration).coinsIdMarketChartRangeGet(id, vsCurrency, from, to, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Candle's body:  1 - 2 days: 30 minutes 3 - 30 days: 4 hours 31 days and beyond: 4 days
         * @summary Get coin's OHLC
         * @param {string} id pass the coin id (can be obtained from /coins/list) eg. bitcoin
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} days  Data up to number of days ago (1/7/14/30/90/180/365/max)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdOhlcGet(id: string, vsCurrency: string, days: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = CoinsApiFetchParamCreator(configuration).coinsIdOhlcGet(id, vsCurrency, days, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get coin tickers (paginated to 100 items)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get coin tickers (paginated to 100 items)
         * @param {string} id pass the coin id (can be obtained from /coins/list) eg. bitcoin
         * @param {string} [exchangeIds] filter results by exchange_ids (ref: v3/exchanges/list)
         * @param {string} [includeExchangeLogo] flag to show exchange_logo
         * @param {number} [page] Page through results
         * @param {string} [order] valid values: &lt;b&gt;trust_score_desc (default), trust_score_asc and volume_desc&lt;/b&gt;
         * @param {string} [depth] flag to show 2% orderbook depth. valid values: true, false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdTickersGet(id: string, exchangeIds?: string, includeExchangeLogo?: string, page?: number, order?: string, depth?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoinsApiFetchParamCreator(configuration).coinsIdTickersGet(id, exchangeIds, includeExchangeLogo, page, order, depth, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this to obtain all the coins' id in order to make API calls
         * @summary List all supported coins id, name and symbol (no pagination required)
         * @param {boolean} [includePlatform] flag to include platform contract addresses (eg. 0x.... for Ethereum based tokens).   valid values: true, false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsListGet(includePlatform?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoinsApiFetchParamCreator(configuration).coinsListGet(includePlatform, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this to obtain all the coins market data (price, market cap, volume)
         * @summary List all supported coins price, market cap, volume, and market related data
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} [ids] The ids of the coin, comma separated crytocurrency symbols (base). refers to &#x60;/coins/list&#x60;. &lt;b&gt;When left empty, returns numbers the coins observing the params &#x60;limit&#x60; and &#x60;start&#x60;&lt;/b&gt;
         * @param {string} [category] filter by coin category. Refer to /coin/categories/list
         * @param {string} [order] valid values: &lt;b&gt;market_cap_desc, gecko_desc, gecko_asc, market_cap_asc, market_cap_desc, volume_asc, volume_desc, id_asc, id_desc&lt;/b&gt; sort results by field.
         * @param {number} [perPage] valid values: 1..250  Total results per page
         * @param {number} [page] Page through results
         * @param {boolean} [sparkline] Include sparkline 7 days data (eg. true, false)
         * @param {string} [priceChangePercentage] Include price change percentage in &lt;b&gt;1h, 24h, 7d, 14d, 30d, 200d, 1y&lt;/b&gt; (eg. &#x27;&#x60;1h,24h,7d&#x60;&#x27; comma-separated, invalid values will be discarded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsMarketsGet(vsCurrency: string, ids?: string, category?: string, order?: string, perPage?: number, page?: number, sparkline?: boolean, priceChangePercentage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CoinsApiFetchParamCreator(configuration).coinsMarketsGet(vsCurrency, ids, category, order, perPage, page, sparkline, priceChangePercentage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CoinsApi - factory interface
 * @export
 */
export const CoinsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get current data (name, price, market, ... including exchange tickers) for a coin.<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/coins/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get current data (name, price, market, ... including exchange tickers) for a coin
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} [localization] Include all localized languages in response (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [tickers] Include tickers data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [marketData] Include market_data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [communityData] Include community_data data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [developerData] Include developer_data data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
         * @param {boolean} [sparkline] Include sparkline 7 days data (eg. true, false) &lt;b&gt;[default: false]&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdGet(id: string, localization?: string, tickers?: boolean, marketData?: boolean, communityData?: boolean, developerData?: boolean, sparkline?: boolean, options?: any) {
            return CoinsApiFp(configuration).coinsIdGet(id, localization, tickers, marketData, communityData, developerData, sparkline, options)(fetch, basePath);
        },
        /**
         * Get historical data (name, price, market, stats) at a given date for a coin
         * @summary Get historical data (name, price, market, stats) at a given date for a coin
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} date The date of data snapshot in dd-mm-yyyy eg. 30-12-2017
         * @param {string} [localization] Set to false to exclude localized languages in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdHistoryGet(id: string, date: string, localization?: string, options?: any) {
            return CoinsApiFp(configuration).coinsIdHistoryGet(id, date, localization, options)(fetch, basePath);
        },
        /**
         * Get historical market data include price, market cap, and 24h volume (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from current time = 5 minute interval data</li><li>1 - 90 days from current time = hourly data</li><li>above 90 days from current time = daily data (00:00 UTC)</li></ul> </b>
         * @summary Get historical market data include price, market cap, and 24h volume (granularity auto)
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} days Data up to number of days ago (eg. 1,14,30,max)
         * @param {string} [interval] Data interval. Possible value: daily
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdMarketChartGet(id: string, vsCurrency: string, days: string, interval?: string, options?: any) {
            return CoinsApiFp(configuration).coinsIdMarketChartGet(id, vsCurrency, days, interval, options)(fetch, basePath);
        },
        /**
         * Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from current time = 5 minute interval data</li><li>1 - 90 days from current time = hourly data</li><li>above 90 days from current time = daily data (00:00 UTC)</li></ul> </b>
         * @summary Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)
         * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} from From date in UNIX Timestamp (eg. 1392577232)
         * @param {string} to To date in UNIX Timestamp (eg. 1422577232)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdMarketChartRangeGet(id: string, vsCurrency: string, from: string, to: string, options?: any) {
            return CoinsApiFp(configuration).coinsIdMarketChartRangeGet(id, vsCurrency, from, to, options)(fetch, basePath);
        },
        /**
         * Candle's body:  1 - 2 days: 30 minutes 3 - 30 days: 4 hours 31 days and beyond: 4 days
         * @summary Get coin's OHLC
         * @param {string} id pass the coin id (can be obtained from /coins/list) eg. bitcoin
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} days  Data up to number of days ago (1/7/14/30/90/180/365/max)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdOhlcGet(id: string, vsCurrency: string, days: string, options?: any) {
            return CoinsApiFp(configuration).coinsIdOhlcGet(id, vsCurrency, days, options)(fetch, basePath);
        },
        /**
         * Get coin tickers (paginated to 100 items)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get coin tickers (paginated to 100 items)
         * @param {string} id pass the coin id (can be obtained from /coins/list) eg. bitcoin
         * @param {string} [exchangeIds] filter results by exchange_ids (ref: v3/exchanges/list)
         * @param {string} [includeExchangeLogo] flag to show exchange_logo
         * @param {number} [page] Page through results
         * @param {string} [order] valid values: &lt;b&gt;trust_score_desc (default), trust_score_asc and volume_desc&lt;/b&gt;
         * @param {string} [depth] flag to show 2% orderbook depth. valid values: true, false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdTickersGet(id: string, exchangeIds?: string, includeExchangeLogo?: string, page?: number, order?: string, depth?: string, options?: any) {
            return CoinsApiFp(configuration).coinsIdTickersGet(id, exchangeIds, includeExchangeLogo, page, order, depth, options)(fetch, basePath);
        },
        /**
         * Use this to obtain all the coins' id in order to make API calls
         * @summary List all supported coins id, name and symbol (no pagination required)
         * @param {boolean} [includePlatform] flag to include platform contract addresses (eg. 0x.... for Ethereum based tokens).   valid values: true, false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsListGet(includePlatform?: boolean, options?: any) {
            return CoinsApiFp(configuration).coinsListGet(includePlatform, options)(fetch, basePath);
        },
        /**
         * Use this to obtain all the coins market data (price, market cap, volume)
         * @summary List all supported coins price, market cap, volume, and market related data
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} [ids] The ids of the coin, comma separated crytocurrency symbols (base). refers to &#x60;/coins/list&#x60;. &lt;b&gt;When left empty, returns numbers the coins observing the params &#x60;limit&#x60; and &#x60;start&#x60;&lt;/b&gt;
         * @param {string} [category] filter by coin category. Refer to /coin/categories/list
         * @param {string} [order] valid values: &lt;b&gt;market_cap_desc, gecko_desc, gecko_asc, market_cap_asc, market_cap_desc, volume_asc, volume_desc, id_asc, id_desc&lt;/b&gt; sort results by field.
         * @param {number} [perPage] valid values: 1..250  Total results per page
         * @param {number} [page] Page through results
         * @param {boolean} [sparkline] Include sparkline 7 days data (eg. true, false)
         * @param {string} [priceChangePercentage] Include price change percentage in &lt;b&gt;1h, 24h, 7d, 14d, 30d, 200d, 1y&lt;/b&gt; (eg. &#x27;&#x60;1h,24h,7d&#x60;&#x27; comma-separated, invalid values will be discarded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsMarketsGet(vsCurrency: string, ids?: string, category?: string, order?: string, perPage?: number, page?: number, sparkline?: boolean, priceChangePercentage?: string, options?: any) {
            return CoinsApiFp(configuration).coinsMarketsGet(vsCurrency, ids, category, order, perPage, page, sparkline, priceChangePercentage, options)(fetch, basePath);
        },
    };
};

/**
 * CoinsApi - object-oriented interface
 * @export
 * @class CoinsApi
 * @extends {BaseAPI}
 */
export class CoinsApi extends BaseAPI {
    /**
     * Get current data (name, price, market, ... including exchange tickers) for a coin.<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/coins/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
     * @summary Get current data (name, price, market, ... including exchange tickers) for a coin
     * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
     * @param {string} [localization] Include all localized languages in response (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
     * @param {boolean} [tickers] Include tickers data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
     * @param {boolean} [marketData] Include market_data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
     * @param {boolean} [communityData] Include community_data data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
     * @param {boolean} [developerData] Include developer_data data (true/false) &lt;b&gt;[default: true]&lt;/b&gt;
     * @param {boolean} [sparkline] Include sparkline 7 days data (eg. true, false) &lt;b&gt;[default: false]&lt;/b&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinsApi
     */
    public coinsIdGet(id: string, localization?: string, tickers?: boolean, marketData?: boolean, communityData?: boolean, developerData?: boolean, sparkline?: boolean, options?: any) {
        return CoinsApiFp(this.configuration).coinsIdGet(id, localization, tickers, marketData, communityData, developerData, sparkline, options)(this.fetch, this.basePath);
    }

    /**
     * Get historical data (name, price, market, stats) at a given date for a coin
     * @summary Get historical data (name, price, market, stats) at a given date for a coin
     * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
     * @param {string} date The date of data snapshot in dd-mm-yyyy eg. 30-12-2017
     * @param {string} [localization] Set to false to exclude localized languages in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinsApi
     */
    public coinsIdHistoryGet(id: string, date: string, localization?: string, options?: any) {
        return CoinsApiFp(this.configuration).coinsIdHistoryGet(id, date, localization, options)(this.fetch, this.basePath);
    }

    /**
     * Get historical market data include price, market cap, and 24h volume (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from current time = 5 minute interval data</li><li>1 - 90 days from current time = hourly data</li><li>above 90 days from current time = daily data (00:00 UTC)</li></ul> </b>
     * @summary Get historical market data include price, market cap, and 24h volume (granularity auto)
     * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
     * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
     * @param {string} days Data up to number of days ago (eg. 1,14,30,max)
     * @param {string} [interval] Data interval. Possible value: daily
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinsApi
     */
    public coinsIdMarketChartGet(id: string, vsCurrency: string, days: string, interval?: string, options?: any) {
        return CoinsApiFp(this.configuration).coinsIdMarketChartGet(id, vsCurrency, days, interval, options)(this.fetch, this.basePath);
    }

    /**
     * Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from current time = 5 minute interval data</li><li>1 - 90 days from current time = hourly data</li><li>above 90 days from current time = daily data (00:00 UTC)</li></ul> </b>
     * @summary Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)
     * @param {string} id pass the coin id (can be obtained from /coins) eg. bitcoin
     * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
     * @param {string} from From date in UNIX Timestamp (eg. 1392577232)
     * @param {string} to To date in UNIX Timestamp (eg. 1422577232)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinsApi
     */
    public coinsIdMarketChartRangeGet(id: string, vsCurrency: string, from: string, to: string, options?: any) {
        return CoinsApiFp(this.configuration).coinsIdMarketChartRangeGet(id, vsCurrency, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * Candle's body:  1 - 2 days: 30 minutes 3 - 30 days: 4 hours 31 days and beyond: 4 days
     * @summary Get coin's OHLC
     * @param {string} id pass the coin id (can be obtained from /coins/list) eg. bitcoin
     * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
     * @param {string} days  Data up to number of days ago (1/7/14/30/90/180/365/max)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinsApi
     */
    public coinsIdOhlcGet(id: string, vsCurrency: string, days: string, options?: any) {
        return CoinsApiFp(this.configuration).coinsIdOhlcGet(id, vsCurrency, days, options)(this.fetch, this.basePath);
    }

    /**
     * Get coin tickers (paginated to 100 items)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
     * @summary Get coin tickers (paginated to 100 items)
     * @param {string} id pass the coin id (can be obtained from /coins/list) eg. bitcoin
     * @param {string} [exchangeIds] filter results by exchange_ids (ref: v3/exchanges/list)
     * @param {string} [includeExchangeLogo] flag to show exchange_logo
     * @param {number} [page] Page through results
     * @param {string} [order] valid values: &lt;b&gt;trust_score_desc (default), trust_score_asc and volume_desc&lt;/b&gt;
     * @param {string} [depth] flag to show 2% orderbook depth. valid values: true, false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinsApi
     */
    public coinsIdTickersGet(id: string, exchangeIds?: string, includeExchangeLogo?: string, page?: number, order?: string, depth?: string, options?: any) {
        return CoinsApiFp(this.configuration).coinsIdTickersGet(id, exchangeIds, includeExchangeLogo, page, order, depth, options)(this.fetch, this.basePath);
    }

    /**
     * Use this to obtain all the coins' id in order to make API calls
     * @summary List all supported coins id, name and symbol (no pagination required)
     * @param {boolean} [includePlatform] flag to include platform contract addresses (eg. 0x.... for Ethereum based tokens).   valid values: true, false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinsApi
     */
    public coinsListGet(includePlatform?: boolean, options?: any) {
        return CoinsApiFp(this.configuration).coinsListGet(includePlatform, options)(this.fetch, this.basePath);
    }

    /**
     * Use this to obtain all the coins market data (price, market cap, volume)
     * @summary List all supported coins price, market cap, volume, and market related data
     * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
     * @param {string} [ids] The ids of the coin, comma separated crytocurrency symbols (base). refers to &#x60;/coins/list&#x60;. &lt;b&gt;When left empty, returns numbers the coins observing the params &#x60;limit&#x60; and &#x60;start&#x60;&lt;/b&gt;
     * @param {string} [category] filter by coin category. Refer to /coin/categories/list
     * @param {string} [order] valid values: &lt;b&gt;market_cap_desc, gecko_desc, gecko_asc, market_cap_asc, market_cap_desc, volume_asc, volume_desc, id_asc, id_desc&lt;/b&gt; sort results by field.
     * @param {number} [perPage] valid values: 1..250  Total results per page
     * @param {number} [page] Page through results
     * @param {boolean} [sparkline] Include sparkline 7 days data (eg. true, false)
     * @param {string} [priceChangePercentage] Include price change percentage in &lt;b&gt;1h, 24h, 7d, 14d, 30d, 200d, 1y&lt;/b&gt; (eg. &#x27;&#x60;1h,24h,7d&#x60;&#x27; comma-separated, invalid values will be discarded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinsApi
     */
    public coinsMarketsGet(vsCurrency: string, ids?: string, category?: string, order?: string, perPage?: number, page?: number, sparkline?: boolean, priceChangePercentage?: string, options?: any) {
        return CoinsApiFp(this.configuration).coinsMarketsGet(vsCurrency, ids, category, order, perPage, page, sparkline, priceChangePercentage, options)(this.fetch, this.basePath);
    }

}
/**
 * CompaniesBetaApi - fetch parameter creator
 * @export
 */
export const CompaniesBetaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get public companies bitcoin or ethereum holdings (Ordered by total holdings descending)
         * @summary Get public companies data
         * @param {string} coinId bitcoin or ethereum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesPublicTreasuryCoinIdGet(coinId: string, options: any = {}): FetchArgs {
            // verify required parameter 'coinId' is not null or undefined
            if (coinId === null || coinId === undefined) {
                throw new RequiredError('coinId','Required parameter coinId was null or undefined when calling companiesPublicTreasuryCoinIdGet.');
            }
            const localVarPath = `/companies/public_treasury/{coin_id}`
                .replace(`{${"coin_id"}}`, encodeURIComponent(String(coinId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompaniesBetaApi - functional programming interface
 * @export
 */
export const CompaniesBetaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get public companies bitcoin or ethereum holdings (Ordered by total holdings descending)
         * @summary Get public companies data
         * @param {string} coinId bitcoin or ethereum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesPublicTreasuryCoinIdGet(coinId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CompaniesBetaApiFetchParamCreator(configuration).companiesPublicTreasuryCoinIdGet(coinId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompaniesBetaApi - factory interface
 * @export
 */
export const CompaniesBetaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get public companies bitcoin or ethereum holdings (Ordered by total holdings descending)
         * @summary Get public companies data
         * @param {string} coinId bitcoin or ethereum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companiesPublicTreasuryCoinIdGet(coinId: string, options?: any) {
            return CompaniesBetaApiFp(configuration).companiesPublicTreasuryCoinIdGet(coinId, options)(fetch, basePath);
        },
    };
};

/**
 * CompaniesBetaApi - object-oriented interface
 * @export
 * @class CompaniesBetaApi
 * @extends {BaseAPI}
 */
export class CompaniesBetaApi extends BaseAPI {
    /**
     * Get public companies bitcoin or ethereum holdings (Ordered by total holdings descending)
     * @summary Get public companies data
     * @param {string} coinId bitcoin or ethereum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesBetaApi
     */
    public companiesPublicTreasuryCoinIdGet(coinId: string, options?: any) {
        return CompaniesBetaApiFp(this.configuration).companiesPublicTreasuryCoinIdGet(coinId, options)(this.fetch, this.basePath);
    }

}
/**
 * ContractApi - fetch parameter creator
 * @export
 */
export const ContractApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get coin info from contract address
         * @summary Get coin info from contract address
         * @param {string} id Asset platform (See asset_platforms endpoint for list of options)
         * @param {string} contractAddress Token&#x27;s contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdContractContractAddressGet(id: string, contractAddress: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coinsIdContractContractAddressGet.');
            }
            // verify required parameter 'contractAddress' is not null or undefined
            if (contractAddress === null || contractAddress === undefined) {
                throw new RequiredError('contractAddress','Required parameter contractAddress was null or undefined when calling coinsIdContractContractAddressGet.');
            }
            const localVarPath = `/coins/{id}/contract/{contract_address}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical market data include price, market cap, and 24h volume (granularity auto)
         * @summary Get historical market data include price, market cap, and 24h volume (granularity auto) from a contract address
         * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
         * @param {string} contractAddress Token&#x27;s contract address
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} days Data up to number of days ago (eg. 1,14,30,max)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdContractContractAddressMarketChartGet(id: string, contractAddress: string, vsCurrency: string, days: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coinsIdContractContractAddressMarketChartGet.');
            }
            // verify required parameter 'contractAddress' is not null or undefined
            if (contractAddress === null || contractAddress === undefined) {
                throw new RequiredError('contractAddress','Required parameter contractAddress was null or undefined when calling coinsIdContractContractAddressMarketChartGet.');
            }
            // verify required parameter 'vsCurrency' is not null or undefined
            if (vsCurrency === null || vsCurrency === undefined) {
                throw new RequiredError('vsCurrency','Required parameter vsCurrency was null or undefined when calling coinsIdContractContractAddressMarketChartGet.');
            }
            // verify required parameter 'days' is not null or undefined
            if (days === null || days === undefined) {
                throw new RequiredError('days','Required parameter days was null or undefined when calling coinsIdContractContractAddressMarketChartGet.');
            }
            const localVarPath = `/coins/{id}/contract/{contract_address}/market_chart/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vsCurrency !== undefined) {
                localVarQueryParameter['vs_currency'] = vsCurrency;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)
         * @summary Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto) from a contract address
         * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
         * @param {string} contractAddress Token&#x27;s contract address
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} from From date in UNIX Timestamp (eg. 1392577232)
         * @param {string} to To date in UNIX Timestamp (eg. 1422577232)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdContractContractAddressMarketChartRangeGet(id: string, contractAddress: string, vsCurrency: string, from: string, to: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling coinsIdContractContractAddressMarketChartRangeGet.');
            }
            // verify required parameter 'contractAddress' is not null or undefined
            if (contractAddress === null || contractAddress === undefined) {
                throw new RequiredError('contractAddress','Required parameter contractAddress was null or undefined when calling coinsIdContractContractAddressMarketChartRangeGet.');
            }
            // verify required parameter 'vsCurrency' is not null or undefined
            if (vsCurrency === null || vsCurrency === undefined) {
                throw new RequiredError('vsCurrency','Required parameter vsCurrency was null or undefined when calling coinsIdContractContractAddressMarketChartRangeGet.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling coinsIdContractContractAddressMarketChartRangeGet.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling coinsIdContractContractAddressMarketChartRangeGet.');
            }
            const localVarPath = `/coins/{id}/contract/{contract_address}/market_chart/range`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vsCurrency !== undefined) {
                localVarQueryParameter['vs_currency'] = vsCurrency;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractApi - functional programming interface
 * @export
 */
export const ContractApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get coin info from contract address
         * @summary Get coin info from contract address
         * @param {string} id Asset platform (See asset_platforms endpoint for list of options)
         * @param {string} contractAddress Token&#x27;s contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdContractContractAddressGet(id: string, contractAddress: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContractApiFetchParamCreator(configuration).coinsIdContractContractAddressGet(id, contractAddress, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get historical market data include price, market cap, and 24h volume (granularity auto)
         * @summary Get historical market data include price, market cap, and 24h volume (granularity auto) from a contract address
         * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
         * @param {string} contractAddress Token&#x27;s contract address
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} days Data up to number of days ago (eg. 1,14,30,max)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdContractContractAddressMarketChartGet(id: string, contractAddress: string, vsCurrency: string, days: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContractApiFetchParamCreator(configuration).coinsIdContractContractAddressMarketChartGet(id, contractAddress, vsCurrency, days, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)
         * @summary Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto) from a contract address
         * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
         * @param {string} contractAddress Token&#x27;s contract address
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} from From date in UNIX Timestamp (eg. 1392577232)
         * @param {string} to To date in UNIX Timestamp (eg. 1422577232)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdContractContractAddressMarketChartRangeGet(id: string, contractAddress: string, vsCurrency: string, from: string, to: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContractApiFetchParamCreator(configuration).coinsIdContractContractAddressMarketChartRangeGet(id, contractAddress, vsCurrency, from, to, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContractApi - factory interface
 * @export
 */
export const ContractApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get coin info from contract address
         * @summary Get coin info from contract address
         * @param {string} id Asset platform (See asset_platforms endpoint for list of options)
         * @param {string} contractAddress Token&#x27;s contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdContractContractAddressGet(id: string, contractAddress: string, options?: any) {
            return ContractApiFp(configuration).coinsIdContractContractAddressGet(id, contractAddress, options)(fetch, basePath);
        },
        /**
         * Get historical market data include price, market cap, and 24h volume (granularity auto)
         * @summary Get historical market data include price, market cap, and 24h volume (granularity auto) from a contract address
         * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
         * @param {string} contractAddress Token&#x27;s contract address
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} days Data up to number of days ago (eg. 1,14,30,max)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdContractContractAddressMarketChartGet(id: string, contractAddress: string, vsCurrency: string, days: string, options?: any) {
            return ContractApiFp(configuration).coinsIdContractContractAddressMarketChartGet(id, contractAddress, vsCurrency, days, options)(fetch, basePath);
        },
        /**
         * Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)
         * @summary Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto) from a contract address
         * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
         * @param {string} contractAddress Token&#x27;s contract address
         * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
         * @param {string} from From date in UNIX Timestamp (eg. 1392577232)
         * @param {string} to To date in UNIX Timestamp (eg. 1422577232)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinsIdContractContractAddressMarketChartRangeGet(id: string, contractAddress: string, vsCurrency: string, from: string, to: string, options?: any) {
            return ContractApiFp(configuration).coinsIdContractContractAddressMarketChartRangeGet(id, contractAddress, vsCurrency, from, to, options)(fetch, basePath);
        },
    };
};

/**
 * ContractApi - object-oriented interface
 * @export
 * @class ContractApi
 * @extends {BaseAPI}
 */
export class ContractApi extends BaseAPI {
    /**
     * Get coin info from contract address
     * @summary Get coin info from contract address
     * @param {string} id Asset platform (See asset_platforms endpoint for list of options)
     * @param {string} contractAddress Token&#x27;s contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public coinsIdContractContractAddressGet(id: string, contractAddress: string, options?: any) {
        return ContractApiFp(this.configuration).coinsIdContractContractAddressGet(id, contractAddress, options)(this.fetch, this.basePath);
    }

    /**
     * Get historical market data include price, market cap, and 24h volume (granularity auto)
     * @summary Get historical market data include price, market cap, and 24h volume (granularity auto) from a contract address
     * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
     * @param {string} contractAddress Token&#x27;s contract address
     * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
     * @param {string} days Data up to number of days ago (eg. 1,14,30,max)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public coinsIdContractContractAddressMarketChartGet(id: string, contractAddress: string, vsCurrency: string, days: string, options?: any) {
        return ContractApiFp(this.configuration).coinsIdContractContractAddressMarketChartGet(id, contractAddress, vsCurrency, days, options)(this.fetch, this.basePath);
    }

    /**
     * Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)
     * @summary Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto) from a contract address
     * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
     * @param {string} contractAddress Token&#x27;s contract address
     * @param {string} vsCurrency The target currency of market data (usd, eur, jpy, etc.)
     * @param {string} from From date in UNIX Timestamp (eg. 1392577232)
     * @param {string} to To date in UNIX Timestamp (eg. 1422577232)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public coinsIdContractContractAddressMarketChartRangeGet(id: string, contractAddress: string, vsCurrency: string, from: string, to: string, options?: any) {
        return ContractApiFp(this.configuration).coinsIdContractContractAddressMarketChartRangeGet(id, contractAddress, vsCurrency, from, to, options)(this.fetch, this.basePath);
    }

}
/**
 * DerivativesApi - fetch parameter creator
 * @export
 */
export const DerivativesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all derivative exchanges
         * @summary List all derivative exchanges
         * @param {string} [order] order results using following params name_asc，name_desc，open_interest_btc_asc，open_interest_btc_desc，trade_volume_24h_btc_asc，trade_volume_24h_btc_desc
         * @param {number} [perPage] Total results per page
         * @param {number} [page] Page through results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesExchangesGet(order?: string, perPage?: number, page?: number, options: any = {}): FetchArgs {
            const localVarPath = `/derivatives/exchanges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * show derivative exchange data
         * @summary show derivative exchange data
         * @param {string} id pass the exchange id (can be obtained from derivatives/exchanges/list) eg. bitmex
         * @param {string} [includeTickers] [&#x27;all&#x27;, &#x27;unexpired&#x27;] - expired to show unexpired tickers, all to list all tickers, leave blank to omit tickers data in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesExchangesIdGet(id: string, includeTickers?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling derivativesExchangesIdGet.');
            }
            const localVarPath = `/derivatives/exchanges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeTickers !== undefined) {
                localVarQueryParameter['include_tickers'] = includeTickers;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all derivative exchanges name and identifier
         * @summary List all derivative exchanges name and identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesExchangesListGet(options: any = {}): FetchArgs {
            const localVarPath = `/derivatives/exchanges/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all derivative tickers
         * @summary List all derivative tickers
         * @param {string} [includeTickers] [&#x27;all&#x27;, &#x27;unexpired&#x27;] - expired to show unexpired tickers, all to list all tickers, defaults to unexpired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesGet(includeTickers?: string, options: any = {}): FetchArgs {
            const localVarPath = `/derivatives`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeTickers !== undefined) {
                localVarQueryParameter['include_tickers'] = includeTickers;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DerivativesApi - functional programming interface
 * @export
 */
export const DerivativesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all derivative exchanges
         * @summary List all derivative exchanges
         * @param {string} [order] order results using following params name_asc，name_desc，open_interest_btc_asc，open_interest_btc_desc，trade_volume_24h_btc_asc，trade_volume_24h_btc_desc
         * @param {number} [perPage] Total results per page
         * @param {number} [page] Page through results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesExchangesGet(order?: string, perPage?: number, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DerivativesApiFetchParamCreator(configuration).derivativesExchangesGet(order, perPage, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * show derivative exchange data
         * @summary show derivative exchange data
         * @param {string} id pass the exchange id (can be obtained from derivatives/exchanges/list) eg. bitmex
         * @param {string} [includeTickers] [&#x27;all&#x27;, &#x27;unexpired&#x27;] - expired to show unexpired tickers, all to list all tickers, leave blank to omit tickers data in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesExchangesIdGet(id: string, includeTickers?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DerivativesApiFetchParamCreator(configuration).derivativesExchangesIdGet(id, includeTickers, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all derivative exchanges name and identifier
         * @summary List all derivative exchanges name and identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesExchangesListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DerivativesApiFetchParamCreator(configuration).derivativesExchangesListGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all derivative tickers
         * @summary List all derivative tickers
         * @param {string} [includeTickers] [&#x27;all&#x27;, &#x27;unexpired&#x27;] - expired to show unexpired tickers, all to list all tickers, defaults to unexpired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesGet(includeTickers?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DerivativesApiFetchParamCreator(configuration).derivativesGet(includeTickers, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DerivativesApi - factory interface
 * @export
 */
export const DerivativesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all derivative exchanges
         * @summary List all derivative exchanges
         * @param {string} [order] order results using following params name_asc，name_desc，open_interest_btc_asc，open_interest_btc_desc，trade_volume_24h_btc_asc，trade_volume_24h_btc_desc
         * @param {number} [perPage] Total results per page
         * @param {number} [page] Page through results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesExchangesGet(order?: string, perPage?: number, page?: number, options?: any) {
            return DerivativesApiFp(configuration).derivativesExchangesGet(order, perPage, page, options)(fetch, basePath);
        },
        /**
         * show derivative exchange data
         * @summary show derivative exchange data
         * @param {string} id pass the exchange id (can be obtained from derivatives/exchanges/list) eg. bitmex
         * @param {string} [includeTickers] [&#x27;all&#x27;, &#x27;unexpired&#x27;] - expired to show unexpired tickers, all to list all tickers, leave blank to omit tickers data in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesExchangesIdGet(id: string, includeTickers?: string, options?: any) {
            return DerivativesApiFp(configuration).derivativesExchangesIdGet(id, includeTickers, options)(fetch, basePath);
        },
        /**
         * List all derivative exchanges name and identifier
         * @summary List all derivative exchanges name and identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesExchangesListGet(options?: any) {
            return DerivativesApiFp(configuration).derivativesExchangesListGet(options)(fetch, basePath);
        },
        /**
         * List all derivative tickers
         * @summary List all derivative tickers
         * @param {string} [includeTickers] [&#x27;all&#x27;, &#x27;unexpired&#x27;] - expired to show unexpired tickers, all to list all tickers, defaults to unexpired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derivativesGet(includeTickers?: string, options?: any) {
            return DerivativesApiFp(configuration).derivativesGet(includeTickers, options)(fetch, basePath);
        },
    };
};

/**
 * DerivativesApi - object-oriented interface
 * @export
 * @class DerivativesApi
 * @extends {BaseAPI}
 */
export class DerivativesApi extends BaseAPI {
    /**
     * List all derivative exchanges
     * @summary List all derivative exchanges
     * @param {string} [order] order results using following params name_asc，name_desc，open_interest_btc_asc，open_interest_btc_desc，trade_volume_24h_btc_asc，trade_volume_24h_btc_desc
     * @param {number} [perPage] Total results per page
     * @param {number} [page] Page through results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DerivativesApi
     */
    public derivativesExchangesGet(order?: string, perPage?: number, page?: number, options?: any) {
        return DerivativesApiFp(this.configuration).derivativesExchangesGet(order, perPage, page, options)(this.fetch, this.basePath);
    }

    /**
     * show derivative exchange data
     * @summary show derivative exchange data
     * @param {string} id pass the exchange id (can be obtained from derivatives/exchanges/list) eg. bitmex
     * @param {string} [includeTickers] [&#x27;all&#x27;, &#x27;unexpired&#x27;] - expired to show unexpired tickers, all to list all tickers, leave blank to omit tickers data in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DerivativesApi
     */
    public derivativesExchangesIdGet(id: string, includeTickers?: string, options?: any) {
        return DerivativesApiFp(this.configuration).derivativesExchangesIdGet(id, includeTickers, options)(this.fetch, this.basePath);
    }

    /**
     * List all derivative exchanges name and identifier
     * @summary List all derivative exchanges name and identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DerivativesApi
     */
    public derivativesExchangesListGet(options?: any) {
        return DerivativesApiFp(this.configuration).derivativesExchangesListGet(options)(this.fetch, this.basePath);
    }

    /**
     * List all derivative tickers
     * @summary List all derivative tickers
     * @param {string} [includeTickers] [&#x27;all&#x27;, &#x27;unexpired&#x27;] - expired to show unexpired tickers, all to list all tickers, defaults to unexpired
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DerivativesApi
     */
    public derivativesGet(includeTickers?: string, options?: any) {
        return DerivativesApiFp(this.configuration).derivativesGet(includeTickers, options)(this.fetch, this.basePath);
    }

}
/**
 * ExchangeRatesApi - fetch parameter creator
 * @export
 */
export const ExchangeRatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get BTC-to-Currency exchange rates
         * @summary Get BTC-to-Currency exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeRatesGet(options: any = {}): FetchArgs {
            const localVarPath = `/exchange_rates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangeRatesApi - functional programming interface
 * @export
 */
export const ExchangeRatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get BTC-to-Currency exchange rates
         * @summary Get BTC-to-Currency exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeRatesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExchangeRatesApiFetchParamCreator(configuration).exchangeRatesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExchangeRatesApi - factory interface
 * @export
 */
export const ExchangeRatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get BTC-to-Currency exchange rates
         * @summary Get BTC-to-Currency exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeRatesGet(options?: any) {
            return ExchangeRatesApiFp(configuration).exchangeRatesGet(options)(fetch, basePath);
        },
    };
};

/**
 * ExchangeRatesApi - object-oriented interface
 * @export
 * @class ExchangeRatesApi
 * @extends {BaseAPI}
 */
export class ExchangeRatesApi extends BaseAPI {
    /**
     * Get BTC-to-Currency exchange rates
     * @summary Get BTC-to-Currency exchange rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeRatesApi
     */
    public exchangeRatesGet(options?: any) {
        return ExchangeRatesApiFp(this.configuration).exchangeRatesGet(options)(this.fetch, this.basePath);
    }

}
/**
 * ExchangesApi - fetch parameter creator
 * @export
 */
export const ExchangesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all exchanges
         * @summary List all exchanges (Active with trading volumes)
         * @param {number} [perPage] Valid values: 1...250 Total results per page Default value:: 100
         * @param {string} [page] page through results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet(perPage?: number, page?: string, options: any = {}): FetchArgs {
            const localVarPath = `/exchanges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get exchange volume in BTC and tickers<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/exchanges/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get exchange volume in BTC and top 100 tickers only
         * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling exchangesIdGet.');
            }
            const localVarPath = `/exchanges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get exchange tickers (paginated)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get exchange tickers (paginated, 100 tickers per page)
         * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
         * @param {string} [coinIds] filter tickers by coin_ids (ref: v3/coins/list)
         * @param {string} [includeExchangeLogo] flag to show exchange_logo
         * @param {number} [page] Page through results
         * @param {string} [depth] flag to show 2% orderbook depth i.e., cost_to_move_up_usd and cost_to_move_down_usd
         * @param {string} [order] valid values: &lt;b&gt;trust_score_desc (default), trust_score_asc and volume_desc&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesIdTickersGet(id: string, coinIds?: string, includeExchangeLogo?: string, page?: number, depth?: string, order?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling exchangesIdTickersGet.');
            }
            const localVarPath = `/exchanges/{id}/tickers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (coinIds !== undefined) {
                localVarQueryParameter['coin_ids'] = coinIds;
            }

            if (includeExchangeLogo !== undefined) {
                localVarQueryParameter['include_exchange_logo'] = includeExchangeLogo;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get volume_chart data for a given exchange
         * @summary Get volume_chart data for a given exchange
         * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
         * @param {number} days  Data up to number of days ago (eg. 1,14,30)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesIdVolumeChartGet(id: string, days: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling exchangesIdVolumeChartGet.');
            }
            // verify required parameter 'days' is not null or undefined
            if (days === null || days === undefined) {
                throw new RequiredError('days','Required parameter days was null or undefined when calling exchangesIdVolumeChartGet.');
            }
            const localVarPath = `/exchanges/{id}/volume_chart`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to obtain all the markets' id in order to make API calls
         * @summary List all supported markets id and name (no pagination required)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesListGet(options: any = {}): FetchArgs {
            const localVarPath = `/exchanges/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangesApi - functional programming interface
 * @export
 */
export const ExchangesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all exchanges
         * @summary List all exchanges (Active with trading volumes)
         * @param {number} [perPage] Valid values: 1...250 Total results per page Default value:: 100
         * @param {string} [page] page through results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet(perPage?: number, page?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExchangesApiFetchParamCreator(configuration).exchangesGet(perPage, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get exchange volume in BTC and tickers<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/exchanges/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get exchange volume in BTC and top 100 tickers only
         * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExchangesApiFetchParamCreator(configuration).exchangesIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get exchange tickers (paginated)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get exchange tickers (paginated, 100 tickers per page)
         * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
         * @param {string} [coinIds] filter tickers by coin_ids (ref: v3/coins/list)
         * @param {string} [includeExchangeLogo] flag to show exchange_logo
         * @param {number} [page] Page through results
         * @param {string} [depth] flag to show 2% orderbook depth i.e., cost_to_move_up_usd and cost_to_move_down_usd
         * @param {string} [order] valid values: &lt;b&gt;trust_score_desc (default), trust_score_asc and volume_desc&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesIdTickersGet(id: string, coinIds?: string, includeExchangeLogo?: string, page?: number, depth?: string, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExchangesApiFetchParamCreator(configuration).exchangesIdTickersGet(id, coinIds, includeExchangeLogo, page, depth, order, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get volume_chart data for a given exchange
         * @summary Get volume_chart data for a given exchange
         * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
         * @param {number} days  Data up to number of days ago (eg. 1,14,30)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesIdVolumeChartGet(id: string, days: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExchangesApiFetchParamCreator(configuration).exchangesIdVolumeChartGet(id, days, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this to obtain all the markets' id in order to make API calls
         * @summary List all supported markets id and name (no pagination required)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExchangesApiFetchParamCreator(configuration).exchangesListGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExchangesApi - factory interface
 * @export
 */
export const ExchangesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all exchanges
         * @summary List all exchanges (Active with trading volumes)
         * @param {number} [perPage] Valid values: 1...250 Total results per page Default value:: 100
         * @param {string} [page] page through results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet(perPage?: number, page?: string, options?: any) {
            return ExchangesApiFp(configuration).exchangesGet(perPage, page, options)(fetch, basePath);
        },
        /**
         * Get exchange volume in BTC and tickers<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/exchanges/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get exchange volume in BTC and top 100 tickers only
         * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesIdGet(id: string, options?: any) {
            return ExchangesApiFp(configuration).exchangesIdGet(id, options)(fetch, basePath);
        },
        /**
         * Get exchange tickers (paginated)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
         * @summary Get exchange tickers (paginated, 100 tickers per page)
         * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
         * @param {string} [coinIds] filter tickers by coin_ids (ref: v3/coins/list)
         * @param {string} [includeExchangeLogo] flag to show exchange_logo
         * @param {number} [page] Page through results
         * @param {string} [depth] flag to show 2% orderbook depth i.e., cost_to_move_up_usd and cost_to_move_down_usd
         * @param {string} [order] valid values: &lt;b&gt;trust_score_desc (default), trust_score_asc and volume_desc&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesIdTickersGet(id: string, coinIds?: string, includeExchangeLogo?: string, page?: number, depth?: string, order?: string, options?: any) {
            return ExchangesApiFp(configuration).exchangesIdTickersGet(id, coinIds, includeExchangeLogo, page, depth, order, options)(fetch, basePath);
        },
        /**
         * Get volume_chart data for a given exchange
         * @summary Get volume_chart data for a given exchange
         * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
         * @param {number} days  Data up to number of days ago (eg. 1,14,30)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesIdVolumeChartGet(id: string, days: number, options?: any) {
            return ExchangesApiFp(configuration).exchangesIdVolumeChartGet(id, days, options)(fetch, basePath);
        },
        /**
         * Use this to obtain all the markets' id in order to make API calls
         * @summary List all supported markets id and name (no pagination required)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesListGet(options?: any) {
            return ExchangesApiFp(configuration).exchangesListGet(options)(fetch, basePath);
        },
    };
};

/**
 * ExchangesApi - object-oriented interface
 * @export
 * @class ExchangesApi
 * @extends {BaseAPI}
 */
export class ExchangesApi extends BaseAPI {
    /**
     * List all exchanges
     * @summary List all exchanges (Active with trading volumes)
     * @param {number} [perPage] Valid values: 1...250 Total results per page Default value:: 100
     * @param {string} [page] page through results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public exchangesGet(perPage?: number, page?: string, options?: any) {
        return ExchangesApiFp(this.configuration).exchangesGet(perPage, page, options)(this.fetch, this.basePath);
    }

    /**
     * Get exchange volume in BTC and tickers<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/exchanges/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
     * @summary Get exchange volume in BTC and top 100 tickers only
     * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public exchangesIdGet(id: string, options?: any) {
        return ExchangesApiFp(this.configuration).exchangesIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get exchange tickers (paginated)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)
     * @summary Get exchange tickers (paginated, 100 tickers per page)
     * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
     * @param {string} [coinIds] filter tickers by coin_ids (ref: v3/coins/list)
     * @param {string} [includeExchangeLogo] flag to show exchange_logo
     * @param {number} [page] Page through results
     * @param {string} [depth] flag to show 2% orderbook depth i.e., cost_to_move_up_usd and cost_to_move_down_usd
     * @param {string} [order] valid values: &lt;b&gt;trust_score_desc (default), trust_score_asc and volume_desc&lt;/b&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public exchangesIdTickersGet(id: string, coinIds?: string, includeExchangeLogo?: string, page?: number, depth?: string, order?: string, options?: any) {
        return ExchangesApiFp(this.configuration).exchangesIdTickersGet(id, coinIds, includeExchangeLogo, page, depth, order, options)(this.fetch, this.basePath);
    }

    /**
     * Get volume_chart data for a given exchange
     * @summary Get volume_chart data for a given exchange
     * @param {string} id pass the exchange id (can be obtained from /exchanges/list) eg. binance
     * @param {number} days  Data up to number of days ago (eg. 1,14,30)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public exchangesIdVolumeChartGet(id: string, days: number, options?: any) {
        return ExchangesApiFp(this.configuration).exchangesIdVolumeChartGet(id, days, options)(this.fetch, this.basePath);
    }

    /**
     * Use this to obtain all the markets' id in order to make API calls
     * @summary List all supported markets id and name (no pagination required)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangesApi
     */
    public exchangesListGet(options?: any) {
        return ExchangesApiFp(this.configuration).exchangesListGet(options)(this.fetch, this.basePath);
    }

}
/**
 * GlobalApi - fetch parameter creator
 * @export
 */
export const GlobalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Top 100 Cryptocurrency Global Eecentralized Finance(defi) data
         * @summary Get cryptocurrency global decentralized finance(defi) data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalDecentralizedFinanceDefiGet(options: any = {}): FetchArgs {
            const localVarPath = `/global/decentralized_finance_defi`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get cryptocurrency global data
         * @summary Get cryptocurrency global data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGet(options: any = {}): FetchArgs {
            const localVarPath = `/global`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlobalApi - functional programming interface
 * @export
 */
export const GlobalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Top 100 Cryptocurrency Global Eecentralized Finance(defi) data
         * @summary Get cryptocurrency global decentralized finance(defi) data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalDecentralizedFinanceDefiGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GlobalApiFetchParamCreator(configuration).globalDecentralizedFinanceDefiGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get cryptocurrency global data
         * @summary Get cryptocurrency global data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GlobalApiFetchParamCreator(configuration).globalGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GlobalApi - factory interface
 * @export
 */
export const GlobalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get Top 100 Cryptocurrency Global Eecentralized Finance(defi) data
         * @summary Get cryptocurrency global decentralized finance(defi) data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalDecentralizedFinanceDefiGet(options?: any) {
            return GlobalApiFp(configuration).globalDecentralizedFinanceDefiGet(options)(fetch, basePath);
        },
        /**
         * Get cryptocurrency global data
         * @summary Get cryptocurrency global data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGet(options?: any) {
            return GlobalApiFp(configuration).globalGet(options)(fetch, basePath);
        },
    };
};

/**
 * GlobalApi - object-oriented interface
 * @export
 * @class GlobalApi
 * @extends {BaseAPI}
 */
export class GlobalApi extends BaseAPI {
    /**
     * Get Top 100 Cryptocurrency Global Eecentralized Finance(defi) data
     * @summary Get cryptocurrency global decentralized finance(defi) data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public globalDecentralizedFinanceDefiGet(options?: any) {
        return GlobalApiFp(this.configuration).globalDecentralizedFinanceDefiGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get cryptocurrency global data
     * @summary Get cryptocurrency global data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public globalGet(options?: any) {
        return GlobalApiFp(this.configuration).globalGet(options)(this.fetch, this.basePath);
    }

}
/**
 * IndexesApi - fetch parameter creator
 * @export
 */
export const IndexesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all market indexes
         * @summary List all market indexes
         * @param {number} [perPage] Total results per page
         * @param {number} [page] Page through results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexesGet(perPage?: number, page?: number, options: any = {}): FetchArgs {
            const localVarPath = `/indexes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list market indexes id and name
         * @summary list market indexes id and name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexesListGet(options: any = {}): FetchArgs {
            const localVarPath = `/indexes/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get market index by market id and index id
         * @summary get market index by market id and index id
         * @param {string} marketId pass the market id (can be obtained from /exchanges/list)
         * @param {string} id pass the index id (can be obtained from /indexes/list)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexesMarketIdIdGet(marketId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'marketId' is not null or undefined
            if (marketId === null || marketId === undefined) {
                throw new RequiredError('marketId','Required parameter marketId was null or undefined when calling indexesMarketIdIdGet.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling indexesMarketIdIdGet.');
            }
            const localVarPath = `/indexes/{market_id}/{id}`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IndexesApi - functional programming interface
 * @export
 */
export const IndexesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all market indexes
         * @summary List all market indexes
         * @param {number} [perPage] Total results per page
         * @param {number} [page] Page through results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexesGet(perPage?: number, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).indexesGet(perPage, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * list market indexes id and name
         * @summary list market indexes id and name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexesListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).indexesListGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get market index by market id and index id
         * @summary get market index by market id and index id
         * @param {string} marketId pass the market id (can be obtained from /exchanges/list)
         * @param {string} id pass the index id (can be obtained from /indexes/list)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexesMarketIdIdGet(marketId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IndexesApiFetchParamCreator(configuration).indexesMarketIdIdGet(marketId, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IndexesApi - factory interface
 * @export
 */
export const IndexesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all market indexes
         * @summary List all market indexes
         * @param {number} [perPage] Total results per page
         * @param {number} [page] Page through results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexesGet(perPage?: number, page?: number, options?: any) {
            return IndexesApiFp(configuration).indexesGet(perPage, page, options)(fetch, basePath);
        },
        /**
         * list market indexes id and name
         * @summary list market indexes id and name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexesListGet(options?: any) {
            return IndexesApiFp(configuration).indexesListGet(options)(fetch, basePath);
        },
        /**
         * get market index by market id and index id
         * @summary get market index by market id and index id
         * @param {string} marketId pass the market id (can be obtained from /exchanges/list)
         * @param {string} id pass the index id (can be obtained from /indexes/list)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexesMarketIdIdGet(marketId: string, id: string, options?: any) {
            return IndexesApiFp(configuration).indexesMarketIdIdGet(marketId, id, options)(fetch, basePath);
        },
    };
};

/**
 * IndexesApi - object-oriented interface
 * @export
 * @class IndexesApi
 * @extends {BaseAPI}
 */
export class IndexesApi extends BaseAPI {
    /**
     * List all market indexes
     * @summary List all market indexes
     * @param {number} [perPage] Total results per page
     * @param {number} [page] Page through results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexesApi
     */
    public indexesGet(perPage?: number, page?: number, options?: any) {
        return IndexesApiFp(this.configuration).indexesGet(perPage, page, options)(this.fetch, this.basePath);
    }

    /**
     * list market indexes id and name
     * @summary list market indexes id and name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexesApi
     */
    public indexesListGet(options?: any) {
        return IndexesApiFp(this.configuration).indexesListGet(options)(this.fetch, this.basePath);
    }

    /**
     * get market index by market id and index id
     * @summary get market index by market id and index id
     * @param {string} marketId pass the market id (can be obtained from /exchanges/list)
     * @param {string} id pass the index id (can be obtained from /indexes/list)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexesApi
     */
    public indexesMarketIdIdGet(marketId: string, id: string, options?: any) {
        return IndexesApiFp(this.configuration).indexesMarketIdIdGet(marketId, id, options)(this.fetch, this.basePath);
    }

}
/**
 * PingApi - fetch parameter creator
 * @export
 */
export const PingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check API server status
         * @summary Check API server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingGet(options: any = {}): FetchArgs {
            const localVarPath = `/ping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PingApi - functional programming interface
 * @export
 */
export const PingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Check API server status
         * @summary Check API server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PingApiFetchParamCreator(configuration).pingGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PingApi - factory interface
 * @export
 */
export const PingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Check API server status
         * @summary Check API server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingGet(options?: any) {
            return PingApiFp(configuration).pingGet(options)(fetch, basePath);
        },
    };
};

/**
 * PingApi - object-oriented interface
 * @export
 * @class PingApi
 * @extends {BaseAPI}
 */
export class PingApi extends BaseAPI {
    /**
     * Check API server status
     * @summary Check API server status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PingApi
     */
    public pingGet(options?: any) {
        return PingApiFp(this.configuration).pingGet(options)(this.fetch, this.basePath);
    }

}
/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for coins, categories and markets listed on CoinGecko ordered by largest Market Cap first
         * @summary Search for coins, categories and markets on CoinGecko
         * @param {string} query Search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGet(query: string, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling searchGet.');
            }
            const localVarPath = `/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Search for coins, categories and markets listed on CoinGecko ordered by largest Market Cap first
         * @summary Search for coins, categories and markets on CoinGecko
         * @param {string} query Search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGet(query: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).searchGet(query, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Search for coins, categories and markets listed on CoinGecko ordered by largest Market Cap first
         * @summary Search for coins, categories and markets on CoinGecko
         * @param {string} query Search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGet(query: string, options?: any) {
            return SearchApiFp(configuration).searchGet(query, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Search for coins, categories and markets listed on CoinGecko ordered by largest Market Cap first
     * @summary Search for coins, categories and markets on CoinGecko
     * @param {string} query Search string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchGet(query: string, options?: any) {
        return SearchApiFp(this.configuration).searchGet(query, options)(this.fetch, this.basePath);
    }

}
/**
 * SimpleApi - fetch parameter creator
 * @export
 */
export const SimpleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get the current price of any cryptocurrencies in any other supported currencies that you need.
         * @param {string} ids id of coins, comma-separated if querying more than 1 coin *refers to &lt;b&gt;&#x60;coins/list&#x60;&lt;/b&gt;
         * @param {string} vsCurrencies vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to &lt;b&gt;&#x60;simple/supported_vs_currencies&#x60;&lt;/b&gt;
         * @param {string} [includeMarketCap] &lt;b&gt;true/false&lt;/b&gt; to include market_cap, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrVol] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_vol, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrChange] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_change, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [includeLastUpdatedAt] &lt;b&gt;true/false&lt;/b&gt; to include last_updated_at of price, &lt;b&gt;default: false&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simplePriceGet(ids: string, vsCurrencies: string, includeMarketCap?: string, include24hrVol?: string, include24hrChange?: string, includeLastUpdatedAt?: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling simplePriceGet.');
            }
            // verify required parameter 'vsCurrencies' is not null or undefined
            if (vsCurrencies === null || vsCurrencies === undefined) {
                throw new RequiredError('vsCurrencies','Required parameter vsCurrencies was null or undefined when calling simplePriceGet.');
            }
            const localVarPath = `/simple/price`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (vsCurrencies !== undefined) {
                localVarQueryParameter['vs_currencies'] = vsCurrencies;
            }

            if (includeMarketCap !== undefined) {
                localVarQueryParameter['include_market_cap'] = includeMarketCap;
            }

            if (include24hrVol !== undefined) {
                localVarQueryParameter['include_24hr_vol'] = include24hrVol;
            }

            if (include24hrChange !== undefined) {
                localVarQueryParameter['include_24hr_change'] = include24hrChange;
            }

            if (includeLastUpdatedAt !== undefined) {
                localVarQueryParameter['include_last_updated_at'] = includeLastUpdatedAt;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of supported_vs_currencies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleSupportedVsCurrenciesGet(options: any = {}): FetchArgs {
            const localVarPath = `/simple/supported_vs_currencies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get current price of tokens (using contract addresses) for a given platform in any other currency that you need.
         * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
         * @param {string} contractAddresses The contract address of tokens, comma separated
         * @param {string} vsCurrencies vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to &lt;b&gt;&#x60;simple/supported_vs_currencies&#x60;&lt;/b&gt;
         * @param {string} [includeMarketCap] &lt;b&gt;true/false&lt;/b&gt; to include market_cap, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrVol] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_vol, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrChange] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_change, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [includeLastUpdatedAt] &lt;b&gt;true/false&lt;/b&gt; to include last_updated_at of price, &lt;b&gt;default: false&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleTokenPriceIdGet(id: string, contractAddresses: string, vsCurrencies: string, includeMarketCap?: string, include24hrVol?: string, include24hrChange?: string, includeLastUpdatedAt?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling simpleTokenPriceIdGet.');
            }
            // verify required parameter 'contractAddresses' is not null or undefined
            if (contractAddresses === null || contractAddresses === undefined) {
                throw new RequiredError('contractAddresses','Required parameter contractAddresses was null or undefined when calling simpleTokenPriceIdGet.');
            }
            // verify required parameter 'vsCurrencies' is not null or undefined
            if (vsCurrencies === null || vsCurrencies === undefined) {
                throw new RequiredError('vsCurrencies','Required parameter vsCurrencies was null or undefined when calling simpleTokenPriceIdGet.');
            }
            const localVarPath = `/simple/token_price/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contractAddresses !== undefined) {
                localVarQueryParameter['contract_addresses'] = contractAddresses;
            }

            if (vsCurrencies !== undefined) {
                localVarQueryParameter['vs_currencies'] = vsCurrencies;
            }

            if (includeMarketCap !== undefined) {
                localVarQueryParameter['include_market_cap'] = includeMarketCap;
            }

            if (include24hrVol !== undefined) {
                localVarQueryParameter['include_24hr_vol'] = include24hrVol;
            }

            if (include24hrChange !== undefined) {
                localVarQueryParameter['include_24hr_change'] = include24hrChange;
            }

            if (includeLastUpdatedAt !== undefined) {
                localVarQueryParameter['include_last_updated_at'] = includeLastUpdatedAt;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimpleApi - functional programming interface
 * @export
 */
export const SimpleApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get the current price of any cryptocurrencies in any other supported currencies that you need.
         * @param {string} ids id of coins, comma-separated if querying more than 1 coin *refers to &lt;b&gt;&#x60;coins/list&#x60;&lt;/b&gt;
         * @param {string} vsCurrencies vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to &lt;b&gt;&#x60;simple/supported_vs_currencies&#x60;&lt;/b&gt;
         * @param {string} [includeMarketCap] &lt;b&gt;true/false&lt;/b&gt; to include market_cap, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrVol] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_vol, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrChange] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_change, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [includeLastUpdatedAt] &lt;b&gt;true/false&lt;/b&gt; to include last_updated_at of price, &lt;b&gt;default: false&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simplePriceGet(ids: string, vsCurrencies: string, includeMarketCap?: string, include24hrVol?: string, include24hrChange?: string, includeLastUpdatedAt?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SimpleApiFetchParamCreator(configuration).simplePriceGet(ids, vsCurrencies, includeMarketCap, include24hrVol, include24hrChange, includeLastUpdatedAt, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get list of supported_vs_currencies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleSupportedVsCurrenciesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SimpleApiFetchParamCreator(configuration).simpleSupportedVsCurrenciesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get current price of tokens (using contract addresses) for a given platform in any other currency that you need.
         * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
         * @param {string} contractAddresses The contract address of tokens, comma separated
         * @param {string} vsCurrencies vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to &lt;b&gt;&#x60;simple/supported_vs_currencies&#x60;&lt;/b&gt;
         * @param {string} [includeMarketCap] &lt;b&gt;true/false&lt;/b&gt; to include market_cap, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrVol] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_vol, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrChange] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_change, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [includeLastUpdatedAt] &lt;b&gt;true/false&lt;/b&gt; to include last_updated_at of price, &lt;b&gt;default: false&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleTokenPriceIdGet(id: string, contractAddresses: string, vsCurrencies: string, includeMarketCap?: string, include24hrVol?: string, include24hrChange?: string, includeLastUpdatedAt?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SimpleApiFetchParamCreator(configuration).simpleTokenPriceIdGet(id, contractAddresses, vsCurrencies, includeMarketCap, include24hrVol, include24hrChange, includeLastUpdatedAt, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SimpleApi - factory interface
 * @export
 */
export const SimpleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Get the current price of any cryptocurrencies in any other supported currencies that you need.
         * @param {string} ids id of coins, comma-separated if querying more than 1 coin *refers to &lt;b&gt;&#x60;coins/list&#x60;&lt;/b&gt;
         * @param {string} vsCurrencies vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to &lt;b&gt;&#x60;simple/supported_vs_currencies&#x60;&lt;/b&gt;
         * @param {string} [includeMarketCap] &lt;b&gt;true/false&lt;/b&gt; to include market_cap, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrVol] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_vol, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrChange] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_change, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [includeLastUpdatedAt] &lt;b&gt;true/false&lt;/b&gt; to include last_updated_at of price, &lt;b&gt;default: false&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simplePriceGet(ids: string, vsCurrencies: string, includeMarketCap?: string, include24hrVol?: string, include24hrChange?: string, includeLastUpdatedAt?: string, options?: any) {
            return SimpleApiFp(configuration).simplePriceGet(ids, vsCurrencies, includeMarketCap, include24hrVol, include24hrChange, includeLastUpdatedAt, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get list of supported_vs_currencies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleSupportedVsCurrenciesGet(options?: any) {
            return SimpleApiFp(configuration).simpleSupportedVsCurrenciesGet(options)(fetch, basePath);
        },
        /**
         *
         * @summary Get current price of tokens (using contract addresses) for a given platform in any other currency that you need.
         * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
         * @param {string} contractAddresses The contract address of tokens, comma separated
         * @param {string} vsCurrencies vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to &lt;b&gt;&#x60;simple/supported_vs_currencies&#x60;&lt;/b&gt;
         * @param {string} [includeMarketCap] &lt;b&gt;true/false&lt;/b&gt; to include market_cap, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrVol] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_vol, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [include24hrChange] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_change, &lt;b&gt;default: false&lt;/b&gt;
         * @param {string} [includeLastUpdatedAt] &lt;b&gt;true/false&lt;/b&gt; to include last_updated_at of price, &lt;b&gt;default: false&lt;/b&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleTokenPriceIdGet(id: string, contractAddresses: string, vsCurrencies: string, includeMarketCap?: string, include24hrVol?: string, include24hrChange?: string, includeLastUpdatedAt?: string, options?: any) {
            return SimpleApiFp(configuration).simpleTokenPriceIdGet(id, contractAddresses, vsCurrencies, includeMarketCap, include24hrVol, include24hrChange, includeLastUpdatedAt, options)(fetch, basePath);
        },
    };
};

/**
 * SimpleApi - object-oriented interface
 * @export
 * @class SimpleApi
 * @extends {BaseAPI}
 */
export class SimpleApi extends BaseAPI {
    /**
     *
     * @summary Get the current price of any cryptocurrencies in any other supported currencies that you need.
     * @param {string} ids id of coins, comma-separated if querying more than 1 coin *refers to &lt;b&gt;&#x60;coins/list&#x60;&lt;/b&gt;
     * @param {string} vsCurrencies vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to &lt;b&gt;&#x60;simple/supported_vs_currencies&#x60;&lt;/b&gt;
     * @param {string} [includeMarketCap] &lt;b&gt;true/false&lt;/b&gt; to include market_cap, &lt;b&gt;default: false&lt;/b&gt;
     * @param {string} [include24hrVol] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_vol, &lt;b&gt;default: false&lt;/b&gt;
     * @param {string} [include24hrChange] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_change, &lt;b&gt;default: false&lt;/b&gt;
     * @param {string} [includeLastUpdatedAt] &lt;b&gt;true/false&lt;/b&gt; to include last_updated_at of price, &lt;b&gt;default: false&lt;/b&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleApi
     */
    public simplePriceGet(ids: string, vsCurrencies: string, includeMarketCap?: string, include24hrVol?: string, include24hrChange?: string, includeLastUpdatedAt?: string, options?: any) {
        return SimpleApiFp(this.configuration).simplePriceGet(ids, vsCurrencies, includeMarketCap, include24hrVol, include24hrChange, includeLastUpdatedAt, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get list of supported_vs_currencies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleApi
     */
    public simpleSupportedVsCurrenciesGet(options?: any) {
        return SimpleApiFp(this.configuration).simpleSupportedVsCurrenciesGet(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get current price of tokens (using contract addresses) for a given platform in any other currency that you need.
     * @param {string} id The id of the platform issuing tokens (See asset_platforms endpoint for list of options)
     * @param {string} contractAddresses The contract address of tokens, comma separated
     * @param {string} vsCurrencies vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to &lt;b&gt;&#x60;simple/supported_vs_currencies&#x60;&lt;/b&gt;
     * @param {string} [includeMarketCap] &lt;b&gt;true/false&lt;/b&gt; to include market_cap, &lt;b&gt;default: false&lt;/b&gt;
     * @param {string} [include24hrVol] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_vol, &lt;b&gt;default: false&lt;/b&gt;
     * @param {string} [include24hrChange] &lt;b&gt;true/false&lt;/b&gt; to include 24hr_change, &lt;b&gt;default: false&lt;/b&gt;
     * @param {string} [includeLastUpdatedAt] &lt;b&gt;true/false&lt;/b&gt; to include last_updated_at of price, &lt;b&gt;default: false&lt;/b&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleApi
     */
    public simpleTokenPriceIdGet(id: string, contractAddresses: string, vsCurrencies: string, includeMarketCap?: string, include24hrVol?: string, include24hrChange?: string, includeLastUpdatedAt?: string, options?: any) {
        return SimpleApiFp(this.configuration).simpleTokenPriceIdGet(id, contractAddresses, vsCurrencies, includeMarketCap, include24hrVol, include24hrChange, includeLastUpdatedAt, options)(this.fetch, this.basePath);
    }

}
/**
 * TrendingApi - fetch parameter creator
 * @export
 */
export const TrendingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Top-7 trending coins on CoinGecko as searched by users in the last 24 hours (Ordered by most popular first)
         * @summary Get trending search coins (Top-7) on CoinGecko in the last 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrendingGet(options: any = {}): FetchArgs {
            const localVarPath = `/search/trending`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrendingApi - functional programming interface
 * @export
 */
export const TrendingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Top-7 trending coins on CoinGecko as searched by users in the last 24 hours (Ordered by most popular first)
         * @summary Get trending search coins (Top-7) on CoinGecko in the last 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrendingGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TrendingApiFetchParamCreator(configuration).searchTrendingGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TrendingApi - factory interface
 * @export
 */
export const TrendingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Top-7 trending coins on CoinGecko as searched by users in the last 24 hours (Ordered by most popular first)
         * @summary Get trending search coins (Top-7) on CoinGecko in the last 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTrendingGet(options?: any) {
            return TrendingApiFp(configuration).searchTrendingGet(options)(fetch, basePath);
        },
    };
};

/**
 * TrendingApi - object-oriented interface
 * @export
 * @class TrendingApi
 * @extends {BaseAPI}
 */
export class TrendingApi extends BaseAPI {
    /**
     * Top-7 trending coins on CoinGecko as searched by users in the last 24 hours (Ordered by most popular first)
     * @summary Get trending search coins (Top-7) on CoinGecko in the last 24 hours
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendingApi
     */
    public searchTrendingGet(options?: any) {
        return TrendingApiFp(this.configuration).searchTrendingGet(options)(this.fetch, this.basePath);
    }

}
